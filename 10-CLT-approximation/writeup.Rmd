---
title: "Distribution of Order Statistics"
author: "Yan Shen"
date: 11/22/2019
output: 
  html_document:
    code_folding: hide
    theme: journal
    toc: yes
    toc_depth: 5
    toc_float: true
editor_options: 
  chunk_output_type: inline
---

***
# I. Introduction

>__Central limit theorem__ can be an short-cut to computation for sampling distribution of the mean, given the conditions are satisfied:
>
>1. Independent observations
>2. Identically distributed observations
>3. Mean and variance exist
>4. Sample size large enough for convergence


In this blog post, we want to examine if the CTL is accurate by comparing the sampling __distribution generated by simulation and the one implied by central limit theorem__ by QQ-plots.

***
# II. Setup

We will examine __Skew-Normal distribution__ in this post. The Skew-Normal distribution has three parameters: __location__, __scale__, and __slant__.

We will set __location = 0__, __scale = 1__ and keep them unchanged. We will increase the slant and sample size gradually to see their impacts on the QQ-plots: __N = 5, 10, 20, 40; slant = 0, 2, 10, 100__. For each simulation, we generate __5000 draw__. 

```{r, message=FALSE}
require(magrittr)
require(sn)

#set parameters
slant <- c(0,2,10,100)
loc <- 0
sc <- 1

r <- 5000
N <- c(5, 10, 20, 40)
```

***
# III. Calculation

For each QQ-plot, we first calculate the distribution implied by Central Limite Theorem for Skew-Normal distribution. 

> $sample_mean = \xi + \omega\delta\sqrt((\frac{2}{\pi}))$
>
> where $\delta = \frac{\alpha}{sqrt(1 + \alpha^2)}$ 
> and $\xi = location, \omega = scale, \alpha = shape$

Next, we calculate simulate the sampling process and calculate the mean for each simulation. 

Finally, we get the quantiles from both methods and generate a QQ-plot. 
```{r}
generate_qq <- function(slant, N, location = loc, scale = sc, R = r) {
  # Quantities to calculate/generate
  delta <- slant / (sqrt(1 + slant ^ 2))
  pop_mean <- location + scale * delta * sqrt(2 / pi)
  pop_sd <- sqrt(scale ^ 2 * (1 - (2 * delta ^ 2) / pi))
  
  # CLT
  Z <- rnorm(R)
  sample_dist_clt <- Z / sqrt(N) * pop_sd + pop_mean
  
  # sampling by simulation
  sample_sn <-
  array(rsn(
  R * N,
  xi = location,
  omega = scale,
  alpha = slant
  ), dim = c(R, N))
  sample_dist_sim <- apply(sample_sn, 1, mean)
  
  # QQ plot
  qqplot(sample_dist_sim, sample_dist_clt, asp = 1, axes = FALSE, frame.plot=TRUE, ann = FALSE)
  abline(0, 1)
}
```

Then, we repeat the process 15 times, to generate a 4*4 matrix of graphs.  
```{r, cache = TRUE, message=FALSE}
x <- seq(from = -3, to = 3, by = 0.05) 

par(mfrow = c(4,5), mai=c(0.1,0.1,0.1,0.1), oma = c(0, 4, 4, 0))

for(s in slant){
  plot(dsn(x, omega = sc, xi = loc, alpha = s), type = "l", axes = FALSE, frame.plot=TRUE)
  for(n in N){
    generate_qq(slant = s, N = n)
  }
}
mtext('slant = 100        slant = 10        slant = 2        slant = 0'
      , side = 2, outer = TRUE)
mtext('Distribution            N = 5                   N = 10                  N = 20                   N = 40'
      , side = 3, outer = TRUE)
dev.copy(png, "plot.png", , width=500, height=350)
dev.off()
```

***
# IV. Result Intepretation

We can see that the CLT is more accurate when slant is smaller (so that the distribution is more similar to a normal distribution). For each slant, when N gets larger, the estimation is more precise (look at the graph at the bottom right). Generally, we want our slant to be small, if that's not the case, we need large sample size N to ensure relative accurate approximation.